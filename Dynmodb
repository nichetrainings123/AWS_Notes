🔹 Definition

Amazon DynamoDB is a fully managed NoSQL database service by AWS designed for high-performance, low-latency workloads at any scale.
It provides key-value and document data models with single-digit millisecond response times and automatic scaling.

👉 It’s serverless — no servers to manage, patch, or provision.

🔸 Key Characteristics
Feature	Description
NoSQL	Non-relational, schema-less database (key-value or document).
Managed Service	AWS handles infrastructure, scaling, backups, and replication.
Performance	Consistent single-digit millisecond latency.
Scalability	Automatically scales throughput capacity and storage.
Highly Available	Data replicated across multiple AZs by default.
Pay-per-Use	Billed based on reads, writes, and storage.
🔹 Core Components
Component	Description
Table	Container for items (similar to a relational table).
Item	Individual record (like a row in RDS).
Attribute	Data element (like a column).
Primary Key	Unique identifier for each item.
Partition Key (PK)	Simple primary key (single attribute).
Sort Key (SK)	Composite key (PK + SK) for ordering and grouping.
Index	Secondary structure for fast lookups (Global or Local).
Throughput	Read and write capacity of the table.
🔸 Data Model Overview
🧩 Table Structure Example
UserId (PK)	OrderId (SK)	OrderDate	Amount	Status
1001	ORD123	2025-10-10	120	Shipped
1001	ORD124	2025-10-12	80	Pending
1002	ORD101	2025-09-25	200	Delivered

Here:

Partition key = UserId

Sort key = OrderId

Enables queries like “Get all orders for UserId = 1001”

🔹 Key Concepts
Concept	Description
Partition (Physical Storage Unit)	DynamoDB automatically distributes data across partitions.
Capacity Units	Measure of read and write performance.
RCU (Read Capacity Unit)	1 strongly consistent read/sec (4 KB).
WCU (Write Capacity Unit)	1 write/sec (1 KB).
Provisioned Mode	Fixed read/write capacity.
On-Demand Mode	Automatically scales read/write capacity as needed.
TTL (Time To Live)	Automatically deletes expired items.
🔸 Data Access Patterns

DynamoDB supports multiple ways to access data:

GetItem – Retrieve a single item by key.

PutItem – Insert or replace an item.

UpdateItem – Modify specific attributes.

DeleteItem – Remove an item.

Query – Retrieve multiple items by PK (and optionally SK).

Scan – Read all items in a table (expensive).

🔹 Indexes
Type	Description	Use Case
Primary Index	Partition Key (or PK + SK).	Main access pattern.
Local Secondary Index (LSI)	Same PK, different SK.	Sort/filter within same partition.
Global Secondary Index (GSI)	Different PK and SK.	Alternative query paths.

✅ You can define up to 5 LSIs and 20 GSIs per table.

🔸 Architecture Overview
+-------------------------------------------------------+
|                 AWS DynamoDB Architecture             |
+-------------------------------------------------------+
| Application                                           |
|   → via AWS SDKs / CLI / API Gateway / Lambda         |
|                                                       |
| DynamoDB Service                                      |
|   → Request Router → Partition Manager → Storage Nodes|
|                                                       |
| Data automatically replicated across 3 AZs            |
|                                                       |
| Integration with: S3 (Export), Streams, Lambda, DAX    |
+-------------------------------------------------------+

🔹 Read & Write Modes
Mode	Description	Use Case
Provisioned Mode	Predefine RCU and WCU.	Predictable workload.
On-Demand Mode	Pay per request, auto scales.	Variable or unpredictable workload.
🔸 Consistency Models
Type	Description
Eventually Consistent Reads (Default)	Data might be slightly outdated (faster, cheaper).
Strongly Consistent Reads	Always returns latest data (slower, double RCU).
Transactional Reads/Writes	ACID-compliant operations across items/tables.
🔹 DynamoDB Streams

Captures data modification events (insert, update, delete).

Each record in the stream contains before and after images of changes.

Commonly used with AWS Lambda to trigger workflows.

Use Case:
📦 Update inventory in real time or trigger notifications after a new order.

🔸 DAX (DynamoDB Accelerator)
Feature	Description
In-memory cache	Reduces read latency from milliseconds → microseconds.
Fully managed	No need for manual cache management.
Compatible API	Uses same API calls as DynamoDB.
Use Case	Read-heavy workloads.
🔹 Backup and Restore
Type	Description
On-Demand Backup	Manual backups anytime.
Point-in-Time Recovery (PITR)	Continuous backup up to last 35 days.
Export to S3	Export historical data for analytics.
🔸 Security
Feature	Description
IAM Policies	Control table-level or item-level access.
Encryption at Rest	Managed by AWS KMS.
Encryption in Transit	HTTPS (TLS) for API calls.
VPC Endpoints	Secure private connectivity.
Fine-Grained Access Control	Attribute-based access via IAM conditions.
🔹 Monitoring & Metrics
Tool	Purpose
Amazon CloudWatch	Tracks read/write capacity, throttling, latency.
DynamoDB Console Metrics	Shows table and index usage.
CloudTrail	Logs all API calls for auditing.
DynamoDB Streams Metrics	Tracks changes in real time.

Key Metrics:

ConsumedReadCapacityUnits

ConsumedWriteCapacityUnits

ThrottledRequests

SystemErrors

ReturnedItemCount

🔸 Integration with Other AWS Services
Service	Purpose
AWS Lambda	Trigger function when data changes.
S3	Export data or backup.
API Gateway	Build serverless APIs.
Kinesis Data Streams	Real-time analytics on changes.
Athena	Query exported data from S3.
CloudWatch	Monitor table performance.
🔹 Performance Optimization Tips

✅ Use composite keys (PK + SK) for better access patterns.
✅ Design table based on access patterns first.
✅ Avoid full-table scans; use Query instead.
✅ Use GSIs for alternative lookups.
✅ Enable DAX for low-latency reads.
✅ Use BatchGetItem / BatchWriteItem for bulk operations.
✅ Monitor and avoid throttling.
✅ Store large objects in S3 and reference them in DynamoDB.

🔸 Pricing
Component	Description
Read/Write Requests	Based on RCU/WCU or per request in On-Demand mode.
Data Storage	Charged per GB/month.
Streams	Charged per read request unit.
Backup & Restore	Based on backup size and retention.
DAX	Hourly cost per node.
🔹 Common AWS CLI Commands
# List tables
aws dynamodb list-tables

# Create table
aws dynamodb create-table \
  --table-name Customer \
  --attribute-definitions AttributeName=CustomerId,AttributeType=S \
  --key-schema AttributeName=CustomerId,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST

# Insert item
aws dynamodb put-item \
  --table-name Customer \
  --item '{"CustomerId": {"S": "1001"}, "Name": {"S": "John"}, "City": {"S": "Delhi"}}'

# Get item
aws dynamodb get-item \
  --table-name Customer \
  --key '{"CustomerId": {"S": "1001"}}'

# Scan table
aws dynamodb scan --table-name Customer

# Delete table
aws dynamodb delete-table --table-name Customer

🔸 Best Practices

✅ Prefer on-demand mode for unpredictable workloads.
✅ Use provisioned mode with auto-scaling for predictable traffic.
✅ Enable TTL for expiring data automatically.
✅ Use GSIs carefully — they consume capacity separately.
✅ Avoid hot partitions by designing diverse partition keys.
✅ Always enable PITR for production data safety.
✅ Use Batch APIs for efficiency.
✅ Compress large data or move to S3 if over 400 KB per item.

🔹 Common Interview Questions

What is DynamoDB and its data model?

What’s the difference between a partition key and sort key?

Explain GSIs vs LSIs.

What’s the difference between Query and Scan?

How does DynamoDB scale automatically?

What is DynamoDB Streams and its use case?

How do you ensure high availability and durability?

What’s the maximum item size? (✅ 400 KB)

How is DynamoDB priced?

How do you handle hot partitions?

Explain On-Demand vs Provisioned capacity modes.

What is DAX and how does it improve performance?

🔸 Comparison: DynamoDB vs RDS
Feature	DynamoDB	RDS
Type	NoSQL (Key-value / Document)	Relational
Schema	Flexible	Fixed
Scaling	Automatic	Manual / Read replicas
Performance	Millisecond	Millisecond to seconds
Consistency	Eventual / Strong	Strong (ACID)
Pricing Model	Per request / capacity	Per instance hour
Use Case	IoT, gaming, real-time apps	Enterprise transactional apps
🔹 Example Real-World Use Case

📦 E-commerce Order Tracking

Table: Orders

Partition Key: UserId

Sort Key: OrderId

Attributes: OrderStatus, Amount, CreatedAt

Streams: Trigger Lambda to send order confirmation email

DAX: Cache frequent queries like “last 5 orders”
